/*
在第一次植物僵尸世界大战中，植物国的黑玫瑰王子使用了植物国的超超超超级无敌禁术-----”BUG”,
开启了异次元的大门，在一位超超超超...级**的指挥官”辅助器”带领下，打败了僵尸王国，
但是也因此植物国大伤元气，无法再得到异次元的帮助。 过了10000年后，僵尸国王子为了国家的荣誉和发扬祖先的”诺克萨斯”精神，
打算采取”闪电战”战术，一举歼灭植物国的战略要塞，吹起第二次植物僵尸世界大战的号角，但是僵尸王子需要知道植物国现在有几个战略要塞，
才能采取进一步措施，于是开始研究植物国的军事图。
因为僵尸国卫星技术先进，该军事图十分清楚明了，是一个二维的电子网格图，图中只有黑色和白色，只要图中的白色方块外一圈的八个方块中有白色方块，
说明它们属于同一个战略要塞。
Input
多组输入（m = 0结束输入）。
军事图是m*n的二维图，图中”@”表示白色，”*”表示黑色。

第一行包含m,n（1<=n,m<=100）,
接下来m行，每行n个字符。

Output
对于每组输入，输出植物国的战略要塞数量。
Sample Input
1 1
*
3 5
*@*@*
**@**
*@*@*
1 8
@@****@*
5 5
****@
*@@*@
*@**@
@@@*@
@@**@
0 0 
Sample Output
0
1
2
2
思路：每次遇到@时向后搜索
遇到过的@就没用了防止被后面判断到
用一个其他字符覆盖

*/
#include <bits/stdc++.h>
using namespace std;
int m,n;
int fx[9]= {-1,-1,-1,0,0,1,1,1},fy[9]= {-1,0,1,-1,1,-1,0,1};
char a[105][105];
int book[9][9];
int cnt;
bool f=false;
void dfs(int x,int y)
{
	int x1,y1;
	for(int i=0; i<8; i++)
	{
		x1 = x+fx[i];
		y1 = y+fy[i];
		if(a[x1][y1]=='@')
		{
			a[x1][y1] = 'A';
			dfs(x1,y1);
//			if(f==0)
//			{
//				cnt++;
//				f=1;
//			}
		}
	}
}
int main()
{
	while(cin>>m>>n)
	{
		if(m==0)
			break;
		for(int i=1; i<=m; i++)
			for(int j=1; j<=n; j++)
			{
				cin>>a[i][j];
			}
		for(int i=1; i<=m; i++)
			for(int j=1; j<=n; j++)
			{
				if(a[i][j]=='@')
				{
					a[i][j] = 'A',dfs(i,j);
					cnt++;
					//f=false;
				}
			}

		cout<<cnt<<endl;
		cnt=0;
	}
	return 0;
}
